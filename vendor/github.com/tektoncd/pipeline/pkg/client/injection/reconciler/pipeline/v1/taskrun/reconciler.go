/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package taskrun

import (
	context "context"
	json "encoding/json"
	fmt "fmt"
	strings "strings"

	v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
	versioned "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
	pipelinev1 "github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1"
	zap "go.uber.org/zap"
	zapcore "go.uber.org/zap/zapcore"
	corev1 "k8s.io/api/core/v1"
	equality "k8s.io/apimachinery/pkg/api/equality"
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	labels "k8s.io/apimachinery/pkg/labels"
	types "k8s.io/apimachinery/pkg/types"
	sets "k8s.io/apimachinery/pkg/util/sets"
	record "k8s.io/client-go/tools/record"
	controller "knative.dev/pkg/controller"
	kmp "knative.dev/pkg/kmp"
	logging "knative.dev/pkg/logging"
	reconciler "knative.dev/pkg/reconciler"
)

// Interface defines the strongly typed interfaces to be implemented by a
// controller reconciling v1.TaskRun.
type Interface interface {
	// ReconcileKind implements custom logic to reconcile v1.TaskRun. Any changes
	// to the objects .Status or .Finalizers will be propagated to the stored
	// object. It is recommended that implementors do not call any update calls
	// for the Kind inside of ReconcileKind, it is the responsibility of the calling
	// controller to propagate those properties. The resource passed to ReconcileKind
	// will always have an empty deletion timestamp.
	ReconcileKind(ctx context.Context, o *v1.TaskRun) reconciler.Event
}

// Finalizer defines the strongly typed interfaces to be implemented by a
// controller finalizing v1.TaskRun.
type Finalizer interface {
	// FinalizeKind implements custom logic to finalize v1.TaskRun. Any changes
	// to the objects .Status or .Finalizers will be ignored. Returning a nil or
	// Normal type reconciler.Event will allow the finalizer to be deleted on
	// the resource. The resource passed to FinalizeKind will always have a set
	// deletion timestamp.
	FinalizeKind(ctx context.Context, o *v1.TaskRun) reconciler.Event
}

// ReadOnlyInterface defines the strongly typed interfaces to be implemented by a
// controller reconciling v1.TaskRun if they want to process resources for which
// they are not the leader.
type ReadOnlyInterface interface {
	// ObserveKind implements logic to observe v1.TaskRun.
	// This method should not write to the API.
	ObserveKind(ctx context.Context, o *v1.TaskRun) reconciler.Event
}

type doReconcile func(ctx context.Context, o *v1.TaskRun) reconciler.Event

// reconcilerImpl implements controller.Reconciler for v1.TaskRun resources.
type reconcilerImpl struct {
	// LeaderAwareFuncs is inlined to help us implement reconciler.LeaderAware.
	reconciler.LeaderAwareFuncs

	// Client is used to write back status updates.
	Client versioned.Interface

	// Listers index properties about resources.
	Lister pipelinev1.TaskRunLister

	// Recorder is an event recorder for recording Event resources to the
	// Kubernetes API.
	Recorder record.EventRecorder

	// configStore allows for decorating a context with config maps.
	// +optional
	configStore reconciler.ConfigStore

	// reconciler is the implementation of the business logic of the resource.
	reconciler Interface

	// finalizerName is the name of the finalizer to reconcile.
	finalizerName string

	// agentName is the name of the agent this reconciler uses, used as field manager for server-side apply.
	agentName string

	// skipStatusUpdates configures whether or not this reconciler automatically updates
	// the status of the reconciled resource.
	skipStatusUpdates bool
}

// Check that our Reconciler implements controller.Reconciler.
var _ controller.Reconciler = (*reconcilerImpl)(nil)

// Check that our generated Reconciler is always LeaderAware.
var _ reconciler.LeaderAware = (*reconcilerImpl)(nil)

func NewReconciler(ctx context.Context, logger *zap.SugaredLogger, client versioned.Interface, lister pipelinev1.TaskRunLister, recorder record.EventRecorder, r Interface, options ...controller.Options) controller.Reconciler {
	// Check the options function input. It should be 0 or 1.
	if len(options) > 1 {
		logger.Fatal("Up to one options struct is supported, found: ", len(options))
	}

	// Fail fast when users inadvertently implement the other LeaderAware interface.
	// For the typed reconcilers, Promote shouldn't take any arguments.
	if _, ok := r.(reconciler.LeaderAware); ok {
		logger.Fatalf("%T implements the incorrect LeaderAware interface. Promote() should not take an argument as genreconciler handles the enqueuing automatically.", r)
	}

	rec := &reconcilerImpl{
		LeaderAwareFuncs: reconciler.LeaderAwareFuncs{
			PromoteFunc: func(bkt reconciler.Bucket, enq func(reconciler.Bucket, types.NamespacedName)) error {
				all, err := lister.List(labels.Everything())
				if err != nil {
					return err
				}
				for _, elt := range all {
					// TODO: Consider letting users specify a filter in options.
					enq(bkt, types.NamespacedName{
						Namespace: elt.GetNamespace(),
						Name:      elt.GetName(),
					})
				}
				return nil
			},
		},
		Client:        client,
		Lister:        lister,
		Recorder:      recorder,
		reconciler:    r,
		finalizerName: defaultFinalizerName,
		agentName:     defaultControllerAgentName,
	}

	for _, opts := range options {
		if opts.ConfigStore != nil {
			rec.configStore = opts.ConfigStore
		}
		if opts.FinalizerName != "" {
			rec.finalizerName = opts.FinalizerName
		}
		if opts.AgentName != "" {
			rec.agentName = opts.AgentName
		}
		if opts.SkipStatusUpdates {
			rec.skipStatusUpdates = true
		}
		if opts.DemoteFunc != nil {
			rec.DemoteFunc = opts.DemoteFunc
		}
	}

	return rec
}

// Reconcile implements controller.Reconciler
func (r *reconcilerImpl) Reconcile(ctx context.Context, key string) error {
	logger := logging.FromContext(ctx)

	// Initialize the reconciler state. This will convert the namespace/name
	// string into a distinct namespace and name, determine if this instance of
	// the reconciler is the leader, and any additional interfaces implemented
	// by the reconciler. Returns an error is the resource key is invalid.
	s, err := newState(key, r)
	if err != nil {
		logger.Error("Invalid resource key: ", key)
		return nil
	}

	// If we are not the leader, and we don't implement either ReadOnly
	// observer interfaces, then take a fast-path out.
	if s.isNotLeaderNorObserver() {
		return controller.NewSkipKey(key)
	}

	// If configStore is set, attach the frozen configuration to the context.
	if r.configStore != nil {
		ctx = r.configStore.ToContext(ctx)
	}

	// Add the recorder to context.
	ctx = controller.WithEventRecorder(ctx, r.Recorder)

	// Get the resource with this namespace/name.

	getter := r.Lister.TaskRuns(s.namespace)

	original, err := getter.Get(s.name)

	if apierrors.IsNotFound(err) {
		// The resource may no longer exist, in which case we stop processing and call
		// the ObserveDeletion handler if appropriate.
		logger.Debugf("Resource %q no longer exists", key)
		if del, ok := r.reconciler.(reconciler.OnDeletionInterface); ok {
			return del.ObserveDeletion(ctx, types.NamespacedName{
				Namespace: s.namespace,
				Name:      s.name,
			})
		}
		return nil
	} else if err != nil {
		return err
	}

	// Don't modify the informers copy.
	resource := original.DeepCopy()

	var reconcileEvent reconciler.Event

	name, do := s.reconcileMethodFor(resource)
	// Append the target method to the logger.
	logger = logger.With(zap.String("targetMethod", name))
	switch name {
	case reconciler.DoReconcileKind:
		// Set and update the finalizer on resource if r.reconciler
		// implements Finalizer.
		if resource, err = r.setFinalizerIfFinalizer(ctx, resource); err != nil {
			return fmt.Errorf("failed to set finalizers: %w", err)
		}

		// Reconcile this copy of the resource and then write back any status
		// updates regardless of whether the reconciliation errored out.
		reconcileEvent = do(ctx, resource)

	case reconciler.DoFinalizeKind:
		// For finalizing reconcilers, if this resource being marked for deletion
		// and reconciled cleanly (nil or normal event), remove the finalizer.
		reconcileEvent = do(ctx, resource)

		if resource, err = r.clearFinalizer(ctx, resource, reconcileEvent); err != nil {
			return fmt.Errorf("failed to clear finalizers: %w", err)
		}

	case reconciler.DoObserveKind:
		// Observe any changes to this resource, since we are not the leader.
		reconcileEvent = do(ctx, resource)

	}

	// Synchronize the status.
	switch {
	case r.skipStatusUpdates:
		// This reconciler implementation is configured to skip resource updates.
		// This may mean this reconciler does not observe spec, but reconciles external changes.
	case equality.Semantic.DeepEqual(original.Status, resource.Status):
		// If we didn't change anything then don't call updateStatus.
		// This is important because the copy we loaded from the injectionInformer's
		// cache may be stale and we don't want to overwrite a prior update
		// to status with this stale state.
	case !s.isLeader:
		// High-availability reconcilers may have many replicas watching the resource, but only
		// the elected leader is expected to write modifications.
		logger.Warn("Saw status changes when we aren't the leader!")
	default:
		if err = r.updateStatus(ctx, logger, original, resource); err != nil {
			logger.Warnw("Failed to update resource status", zap.Error(err))
			r.Recorder.Eventf(resource, corev1.EventTypeWarning, "UpdateFailed",
				"Failed to update status for %q: %v", resource.Name, err)
			return err
		}
	}

	// Report the reconciler event, if any.
	if reconcileEvent != nil {
		var event *reconciler.ReconcilerEvent
		if reconciler.EventAs(reconcileEvent, &event) {
			logger.Infow("Returned an event", zap.Any("event", reconcileEvent))
			r.Recorder.Event(resource, event.EventType, event.Reason, event.Error())

			// the event was wrapped inside an error, consider the reconciliation as failed
			if _, isEvent := reconcileEvent.(*reconciler.ReconcilerEvent); !isEvent {
				return reconcileEvent
			}
			return nil
		}

		if controller.IsSkipKey(reconcileEvent) {
			// This is a wrapped error, don't emit an event.
		} else if ok, _ := controller.IsRequeueKey(reconcileEvent); ok {
			// This is a wrapped error, don't emit an event.
		} else {
			logger.Errorw("Returned an error", zap.Error(reconcileEvent))
			r.Recorder.Event(resource, corev1.EventTypeWarning, "InternalError", reconcileEvent.Error())
		}
		return reconcileEvent
	}

	return nil
}

func (r *reconcilerImpl) updateStatus(ctx context.Context, logger *zap.SugaredLogger, existing *v1.TaskRun, desired *v1.TaskRun) error {
	existing = existing.DeepCopy()
	return reconciler.RetryUpdateConflicts(func(attempts int) (err error) {
		// The first iteration tries to use the injectionInformer's state, subsequent attempts fetch the latest state via API.
		if attempts > 0 {

			getter := r.Client.TektonV1().TaskRuns(desired.Namespace)

			existing, err = getter.Get(ctx, desired.Name, metav1.GetOptions{})
			if err != nil {
				return err
			}
		}

		// If there's nothing to update, just return.
		if equality.Semantic.DeepEqual(existing.Status, desired.Status) {
			return nil
		}

		if logger.Desugar().Core().Enabled(zapcore.DebugLevel) {
			if diff, err := kmp.SafeDiff(existing.Status, desired.Status); err == nil && diff != "" {
				logger.Debug("Updating status with: ", diff)
			}
		}

		existing.Status = desired.Status

		updater := r.Client.TektonV1().TaskRuns(existing.Namespace)

		_, err = updater.UpdateStatus(ctx, existing, metav1.UpdateOptions{})
		return err
	})
}

// updateFinalizersFiltered will update the Finalizers of the resource.
// Uses server-side apply if AgentName is provided (new behavior), otherwise falls back to merge patch (legacy behavior).
func (r *reconcilerImpl) updateFinalizersFiltered(ctx context.Context, resource *v1.TaskRun, desiredFinalizers sets.Set[string]) (*v1.TaskRun, error) {
	// Don't modify the informers copy.
	existing := resource.DeepCopy()

	// If there's nothing to update, just return.
	existingFinalizers := sets.New[string](existing.Finalizers...)

	if desiredFinalizers.Has(r.finalizerName) {
		if existingFinalizers.Has(r.finalizerName) {
			// Nothing to do.
			return resource, nil
		}
		// Add the finalizer
		return r.addFinalizer(ctx, existing)
	} else {
		if !existingFinalizers.Has(r.finalizerName) {
			// Nothing to do.
			return resource, nil
		}
		// Remove the finalizer
		return r.removeFinalizer(ctx, existing)
	}
}

// addFinalizer adds the finalizer using server-side apply if AgentName is provided, otherwise uses merge patch
func (r *reconcilerImpl) addFinalizer(ctx context.Context, resource *v1.TaskRun) (*v1.TaskRun, error) {
	// Check if AgentName was explicitly provided - if so, use server-side apply
	// Empty agentName means no explicit AgentName was set, so use legacy merge patch
	if r.agentName != "" {
		return r.addFinalizerSSA(ctx, resource)
	}
	// Fall back to legacy merge patch behavior for backward compatibility
	return r.addFinalizerMergePatch(ctx, resource)
}

// removeFinalizer removes the finalizer using server-side apply if AgentName is provided, otherwise uses merge patch
func (r *reconcilerImpl) removeFinalizer(ctx context.Context, resource *v1.TaskRun) (*v1.TaskRun, error) {
	// Check if AgentName was explicitly provided - if so, use server-side apply
	// Empty agentName means no explicit AgentName was set, so use legacy merge patch
	if r.agentName != "" {
		return r.removeFinalizerSSA(ctx, resource)
	}
	// Fall back to legacy merge patch behavior for backward compatibility
	return r.removeFinalizerMergePatch(ctx, resource)
}

// handleSSAErrorForMissingObject checks if the error is a result of trying to create
// a missing object and returns nil to prevent retries. In comparison with merge patch where
// patching a non-existent object results in a permanent error, SSA patch tries to create the
// object which then fails admission validation or RBAC, resulting in a non-permanent error that
// makes the controller requeue and retry until the stale object is gone from the informer cache.
func (r *reconcilerImpl) handleSSAErrorForMissingObject(ctx context.Context, err error, resource *v1.TaskRun) error {
	// Check if this is a BadRequest error (Knative admission webhooks) or Forbidden error (RBAC)
	// Both can indicate SSA trying to create an object when it should just patch it
	if !apierrors.IsBadRequest(err) && !apierrors.IsForbidden(err) {
		return err
	}

	// For Forbidden errors, check if it's specifically about "create" permissions
	// SSA on non-existent objects tries to create the object, which might fail due to RBAC
	if apierrors.IsForbidden(err) && !strings.Contains(err.Error(), "cannot create resource") {
		return err
	}

	// Check if the object actually exists.
	// If the object doesn't exist, then the error is likely due to SSA
	// trying to create a minimal object that fails validation or lacks permissions.
	_, getErr := r.Client.TektonV1().TaskRuns(resource.Namespace).Get(ctx, resource.Name, metav1.GetOptions{})
	if apierrors.IsNotFound(getErr) {
		// Object doesn't exist - this confirms the error is due to
		// server-side apply trying to patch a non-existent object
		logger := logging.FromContext(ctx)
		logger.Debugf("Ignoring SSA error for deleted object %s/%s - no retry needed", resource.Namespace, resource.Name)
		return nil // Object is gone, nothing to retry
	}

	// Object exists or we got a different error - return the original error
	return err
}

// addFinalizerSSA adds only the specific finalizer managed by this controller using server-side apply
func (r *reconcilerImpl) addFinalizerSSA(ctx context.Context, resource *v1.TaskRun) (*v1.TaskRun, error) {
	logger := logging.FromContext(ctx)

	// Create an apply patch that only specifies our specific finalizer
	applyPatch := map[string]interface{}{
		"apiVersion": "tekton.dev/v1",
		"kind":       "TaskRun",
		"metadata": map[string]interface{}{
			"name":       resource.Name,
			"namespace":  resource.Namespace,
			"finalizers": []string{r.finalizerName},
		},
	}

	patch, err := json.Marshal(applyPatch)
	if err != nil {
		return resource, err
	}

	patcher := r.Client.TektonV1().TaskRuns(resource.Namespace)

	// Use specific fieldManager for each field we update (e.g. finalizers, annotations). With
	// Server-Side Apply each fieldManager should always create a patch including all fields it manages.
	// Otherwise they are removed.
	fieldManager := r.agentName + "/finalizers"
	force := false
	updated, err := patcher.Patch(ctx, resource.Name, types.ApplyPatchType, patch, metav1.PatchOptions{
		FieldManager: fieldManager,
		Force:        &force,
	})

	if apierrors.IsConflict(err) {
		// Log warning about conflict and retry with force=true
		logger.Warnf("failed to add finalizer %q to TaskRun %s/%s due to Server-Side Apply conflict, retrying with force=true",
			r.finalizerName, resource.Namespace, resource.Name)
		force = true
		updated, err = patcher.Patch(ctx, resource.Name, types.ApplyPatchType, patch, metav1.PatchOptions{
			FieldManager: fieldManager,
			Force:        &force,
		})
	}

	if err != nil {
		// Check if this is an SSA admission webhook error for missing object. This happens with stale
		// objects in informers cache.
		if missingObjErr := r.handleSSAErrorForMissingObject(ctx, err, resource); missingObjErr != err {
			return resource, missingObjErr
		}
		r.Recorder.Eventf(resource, corev1.EventTypeWarning, "FinalizerUpdateFailed",
			"Failed to add finalizer for %q: %v", resource.Name, err)
	} else {
		r.Recorder.Eventf(updated, corev1.EventTypeNormal, "FinalizerUpdate",
			"Added %q finalizer", resource.GetName())
	}
	return updated, err
}

// removeFinalizerSSA removes only the specific finalizer managed by this controller using server-side apply
func (r *reconcilerImpl) removeFinalizerSSA(ctx context.Context, resource *v1.TaskRun) (*v1.TaskRun, error) {
	logger := logging.FromContext(ctx)

	// Create an apply patch with an empty finalizers list for our field manager
	// This tells server-side apply to remove our finalizer while leaving others intact
	applyPatch := map[string]interface{}{
		"apiVersion": "tekton.dev/v1",
		"kind":       "TaskRun",
		"metadata": map[string]interface{}{
			"name":       resource.Name,
			"namespace":  resource.Namespace,
			"finalizers": []string{},
		},
	}

	patch, err := json.Marshal(applyPatch)
	if err != nil {
		return resource, err
	}

	patcher := r.Client.TektonV1().TaskRuns(resource.Namespace)

	fieldManager := r.agentName + "/finalizers"
	force := false
	updated, err := patcher.Patch(ctx, resource.Name, types.ApplyPatchType, patch, metav1.PatchOptions{
		FieldManager: fieldManager,
		Force:        &force,
	})

	if apierrors.IsConflict(err) {
		// Log warning about conflict and retry with force=true
		logger.Warnf("failed to remove finalizer %q from TaskRun %s/%s due to Server-Side Apply conflict, retrying with force=true",
			r.finalizerName, resource.Namespace, resource.Name)
		force = true
		updated, err = patcher.Patch(ctx, resource.Name, types.ApplyPatchType, patch, metav1.PatchOptions{
			FieldManager: fieldManager,
			Force:        &force,
		})
	}

	if err != nil {
		// Check if this is an SSA admission webhook error for missing object
		if missingObjErr := r.handleSSAErrorForMissingObject(ctx, err, resource); missingObjErr != err {
			return resource, missingObjErr
		}
		r.Recorder.Eventf(resource, corev1.EventTypeWarning, "FinalizerUpdateFailed",
			"Failed to remove finalizer for %q: %v", resource.Name, err)
	} else {
		r.Recorder.Eventf(updated, corev1.EventTypeNormal, "FinalizerUpdate",
			"Removed %q finalizer", resource.GetName())
	}
	return updated, err
}

// addFinalizerMergePatch adds the finalizer using legacy merge patch (backward compatibility)
func (r *reconcilerImpl) addFinalizerMergePatch(ctx context.Context, resource *v1.TaskRun) (*v1.TaskRun, error) {
	// Add the finalizer to the existing list
	finalizers := append(resource.Finalizers, r.finalizerName)

	mergePatch := map[string]interface{}{
		"metadata": map[string]interface{}{
			"finalizers":      finalizers,
			"resourceVersion": resource.ResourceVersion,
		},
	}

	patch, err := json.Marshal(mergePatch)
	if err != nil {
		return resource, err
	}

	patcher := r.Client.TektonV1().TaskRuns(resource.Namespace)
	updated, err := patcher.Patch(ctx, resource.Name, types.MergePatchType, patch, metav1.PatchOptions{})
	if err != nil {
		r.Recorder.Eventf(resource, corev1.EventTypeWarning, "FinalizerUpdateFailed",
			"Failed to add finalizer for %q: %v", resource.Name, err)
	} else {
		r.Recorder.Eventf(updated, corev1.EventTypeNormal, "FinalizerUpdate",
			"Added %q finalizer", resource.GetName())
	}
	return updated, err
}

// removeFinalizerMergePatch removes the finalizer using legacy merge patch (backward compatibility)
func (r *reconcilerImpl) removeFinalizerMergePatch(ctx context.Context, resource *v1.TaskRun) (*v1.TaskRun, error) {
	// Remove the finalizer from the existing list
	existingFinalizers := sets.New[string](resource.Finalizers...)
	existingFinalizers.Delete(r.finalizerName)
	finalizers := sets.List(existingFinalizers)

	mergePatch := map[string]interface{}{
		"metadata": map[string]interface{}{
			"finalizers":      finalizers,
			"resourceVersion": resource.ResourceVersion,
		},
	}

	patch, err := json.Marshal(mergePatch)
	if err != nil {
		return resource, err
	}

	patcher := r.Client.TektonV1().TaskRuns(resource.Namespace)
	updated, err := patcher.Patch(ctx, resource.Name, types.MergePatchType, patch, metav1.PatchOptions{})
	if err != nil {
		r.Recorder.Eventf(resource, corev1.EventTypeWarning, "FinalizerUpdateFailed",
			"Failed to remove finalizer for %q: %v", resource.Name, err)
	} else {
		r.Recorder.Eventf(updated, corev1.EventTypeNormal, "FinalizerUpdate",
			"Removed %q finalizer", resource.GetName())
	}
	return updated, err
}

func (r *reconcilerImpl) setFinalizerIfFinalizer(ctx context.Context, resource *v1.TaskRun) (*v1.TaskRun, error) {
	if _, ok := r.reconciler.(Finalizer); !ok {
		return resource, nil
	}

	finalizers := sets.New[string](resource.Finalizers...)

	// If this resource is not being deleted, mark the finalizer.
	if resource.GetDeletionTimestamp().IsZero() {
		finalizers.Insert(r.finalizerName)
	}

	// Synchronize the finalizers filtered by r.finalizerName.
	return r.updateFinalizersFiltered(ctx, resource, finalizers)
}

func (r *reconcilerImpl) clearFinalizer(ctx context.Context, resource *v1.TaskRun, reconcileEvent reconciler.Event) (*v1.TaskRun, error) {
	if _, ok := r.reconciler.(Finalizer); !ok {
		return resource, nil
	}
	if resource.GetDeletionTimestamp().IsZero() {
		return resource, nil
	}

	finalizers := sets.New[string](resource.Finalizers...)

	if reconcileEvent != nil {
		var event *reconciler.ReconcilerEvent
		if reconciler.EventAs(reconcileEvent, &event) {
			if event.EventType == corev1.EventTypeNormal {
				finalizers.Delete(r.finalizerName)
			}
		}
	} else {
		finalizers.Delete(r.finalizerName)
	}

	// Synchronize the finalizers filtered by r.finalizerName.
	return r.updateFinalizersFiltered(ctx, resource, finalizers)
}
